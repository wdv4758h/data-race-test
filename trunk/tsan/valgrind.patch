Index: Makefile.all.am
===================================================================
--- Makefile.all.am	(revision 10454)
+++ Makefile.all.am	(working copy)
@@ -91,6 +91,9 @@
 	@FLAG_W_NO_FORMAT_ZERO_LENGTH@ \
 	-fno-strict-aliasing
 
+AM_CXXFLAGS_BASE = -O2 -g -fno-exceptions -fno-rtti -Wall -Istlport -fno-stack-protector
+
+
 # These flags are used for building the preload shared objects.
 # The aim is to give reasonable performance but also to have good
 # stack traces, since users often see stack traces extending 
@@ -135,11 +138,15 @@
 AM_FLAG_M3264_X86_LINUX   = @FLAG_M32@
 AM_CFLAGS_X86_LINUX       = @FLAG_M32@ @PREFERRED_STACK_BOUNDARY@ \
 			 	$(AM_CFLAGS_BASE)
+AM_CXXFLAGS_X86_LINUX       = @FLAG_M32@ @PREFERRED_STACK_BOUNDARY@ \
+			 	$(AM_CXXFLAGS_BASE)
 AM_CCASFLAGS_X86_LINUX    = $(AM_CPPFLAGS_X86_LINUX) @FLAG_M32@ -g
 
 AM_FLAG_M3264_AMD64_LINUX = @FLAG_M64@
 AM_CFLAGS_AMD64_LINUX     = @FLAG_M64@ -fomit-frame-pointer \
 				@PREFERRED_STACK_BOUNDARY@ $(AM_CFLAGS_BASE)
+AM_CXXFLAGS_AMD64_LINUX     = @FLAG_M64@ -fomit-frame-pointer \
+				@PREFERRED_STACK_BOUNDARY@ $(AM_CXXFLAGS_BASE)
 AM_CCASFLAGS_AMD64_LINUX  = $(AM_CPPFLAGS_AMD64_LINUX) @FLAG_M64@ -g
 
 AM_FLAG_M3264_PPC32_LINUX = @FLAG_M32@
@@ -178,6 +185,7 @@
 AM_FLAG_M3264_PRI = $(AM_FLAG_M3264_@VGCONF_PLATFORM_PRI_CAPS@)
 AM_CPPFLAGS_PRI   = $(AM_CPPFLAGS_@VGCONF_PLATFORM_PRI_CAPS@)
 AM_CFLAGS_PRI     = $(AM_CFLAGS_@VGCONF_PLATFORM_PRI_CAPS@)
+AM_CXXFLAGS_PR    = $(AM_CXXFLAGS_@VG_PLATFORM_PRI@)
 AM_CCASFLAGS_PRI  = $(AM_CCASFLAGS_@VGCONF_PLATFORM_PRI_CAPS@)
 
 if VGCONF_HAVE_PLATFORM_SEC
Index: include/pub_tool_libcassert.h
===================================================================
--- include/pub_tool_libcassert.h	(revision 10454)
+++ include/pub_tool_libcassert.h	(working copy)
@@ -31,18 +31,20 @@
 #ifndef __PUB_TOOL_LIBCBASSERT_H
 #define __PUB_TOOL_LIBCBASSERT_H
 
-#define tl_assert(expr)                                                 \
-  ((void) ((expr) ? 0 :                                                 \
-           (VG_(assert_fail) (/*isCore?*/False, #expr,                  \
-                              __FILE__, __LINE__, __PRETTY_FUNCTION__,  \
-                              ""),                                      \
+#define tl_assert(expr)                                               \
+((void) ((expr) ? 0 :                                                 \
+         (VG_(assert_fail) (/*isCore?*/False, (Char*)#expr,           \
+                              (Char*)__FILE__, __LINE__,              \
+                              (Char*)__PRETTY_FUNCTION__,             \
+                              ""),                                    \
                               0)))
 
-#define tl_assert2(expr, format, args...)                               \
-  ((void) ((expr) ? 0 :                                                 \
-           (VG_(assert_fail) (/*isCore?*/False, #expr,                  \
-                              __FILE__, __LINE__, __PRETTY_FUNCTION__,  \
-                              format, ##args),                          \
+#define tl_assert2(expr, format, args...)                             \
+  ((void) ((expr) ? 0 :                                               \
+           (VG_(assert_fail) (/*isCore?*/False, (Char*)#expr,         \
+                              (Char*)__FILE__, __LINE__,              \
+                              (Char*)__PRETTY_FUNCTION__,             \
+                              (const HChar*)format, ##args),          \
                               0)))
 
 __attribute__ ((__noreturn__))
Index: include/pub_tool_errormgr.h
===================================================================
--- include/pub_tool_errormgr.h	(revision 10454)
+++ include/pub_tool_errormgr.h	(working copy)
@@ -62,6 +62,14 @@
 Char*       VG_(get_error_string)  ( Error* err );
 void*       VG_(get_error_extra)   ( Error* err );
 
+
+typedef enum {
+  ERROR_IS_RECORDED,
+  ERROR_IS_SUPPRESSED,
+  ERROR_IS_IGNORED_AS_DUPLICATE,
+  ERROR_IS_IGNORED_DUE_TO_LIMIT
+} RecordErrorReturnType;
+
 /* Call this when an error occurs.  It will be recorded if it hasn't been
    seen before.  If it has, the existing error record will have its count
    incremented.
@@ -72,8 +80,10 @@
 
    If no 'a', 's' or 'extra' of interest needs to be recorded, just use
    NULL for them.  */
-extern void VG_(maybe_record_error) ( ThreadId tid, ErrorKind ekind,
-                                      Addr a, Char* s, void* extra );
+extern RecordErrorReturnType VG_(maybe_record_error) ( ThreadId tid, 
+                                                       ErrorKind ekind,
+                                                       Addr a, Char* s, 
+                                                       void* extra );
 
 /* Similar to VG_(maybe_record_error)(), except this one doesn't record the
    error -- useful for errors that can only happen once.  The errors can be
Index: include/vki/vki-x86-linux.h
===================================================================
--- include/vki/vki-x86-linux.h	(revision 10454)
+++ include/vki/vki-x86-linux.h	(working copy)
@@ -479,12 +479,15 @@
 	 ((nr)   << _VKI_IOC_NRSHIFT) | \
 	 ((size) << _VKI_IOC_SIZESHIFT))
 
-/* provoke compile error for invalid uses of size argument */
-extern unsigned int __vki_invalid_size_argument_for_IOC;
+/* The trunk version of the code below intentionally leads to compile-time
+ * error if anything is wrong with type "t".
+ * However, the original code is not C++-compiler-friendly.
+ *
+ * As a workaround, we produce a "division by zero" warning if anything is wrong
+ * with 't'. */
 #define _VKI_IOC_TYPECHECK(t) \
-	((sizeof(t) == sizeof(t[1]) && \
-	  sizeof(t) < (1 << _VKI_IOC_SIZEBITS)) ? \
-	  sizeof(t) : __vki_invalid_size_argument_for_IOC)
+	(sizeof(t) / (sizeof(t) == sizeof(t[1]) && \
+	  sizeof(t) < (1 << _VKI_IOC_SIZEBITS)))
 
 /* used to create numbers */
 #define _VKI_IO(type,nr)	_VKI_IOC(_VKI_IOC_NONE,(type),(nr),0)
Index: configure.in
===================================================================
--- configure.in	(revision 10454)
+++ configure.in	(working copy)
@@ -1354,7 +1354,42 @@
   AC_DEFINE(HAVE_BUILTIN_EXPECT, 1, [Define to 1 if gcc supports __builtin_expect.])
 fi
 
+# does this compiler support __builtin_bswap32?
+AC_MSG_CHECKING([if gcc supports __builtin_bswap32])
 
+AC_TRY_LINK(, [
+return __builtin_bswap32(0x12345678) == 0x78563412
+],
+[
+ac_have_builtin_bswap32=yes
+AC_MSG_RESULT([yes])
+], [
+ac_have_builtin_bswap32=no
+AC_MSG_RESULT([no])
+])
+if test x$ac_have_builtin_bswap32 = xyes ; then
+  AC_DEFINE(HAVE_BUILTIN_BSWAP32, 1, [Define to 1 if gcc supports __builtin_bswap32.])
+fi
+
+# does this compiler support __builtin_bswap64?
+AC_MSG_CHECKING([if gcc supports __builtin_bswap64])
+
+
+AC_TRY_LINK(, [
+return __builtin_bswap64(0x12345678ffffffffLL) == 0xffffffff78563412LL
+],
+[
+ac_have_builtin_bswap64=yes
+AC_MSG_RESULT([yes])
+], [
+ac_have_builtin_bswap64=no
+AC_MSG_RESULT([no])
+])
+if test x$ac_have_builtin_bswap64 = xyes ; then
+  AC_DEFINE(HAVE_BUILTIN_BSWAP64, 1, [Define to 1 if gcc ports __builtin_bswap64.])
+fi
+
+
 # does the ppc assembler support "mtocrf" et al?
 AC_MSG_CHECKING([if ppc32/64 as supports mtocrf/mfocrf])
 
@@ -1872,6 +1907,9 @@
    callgrind/callgrind_control
    callgrind/tests/Makefile
    callgrind/docs/Makefile
+   tsan/Makefile
+   tsan/tests/Makefile
+   tsan/docs/Makefile
    helgrind/Makefile
    helgrind/tests/Makefile
    helgrind/docs/Makefile
Index: Makefile.am
===================================================================
--- Makefile.am	(revision 10454)
+++ Makefile.am	(working copy)
@@ -10,6 +10,7 @@
 		lackey \
 		none \
 		helgrind \
+		tsan \
 		drd
 
 EXP_TOOLS = 	exp-ptrcheck \
Index: coregrind/m_errormgr.c
===================================================================
--- coregrind/m_errormgr.c	(revision 10454)
+++ coregrind/m_errormgr.c	(working copy)
@@ -476,7 +476,7 @@
 /* Top-level entry point to the error management subsystem.
    All detected errors are notified here; this routine decides if/when the
    user should see the error. */
-void VG_(maybe_record_error) ( ThreadId tid, 
+RecordErrorReturnType VG_(maybe_record_error) ( ThreadId tid, 
                                ErrorKind ekind, Addr a, Char* s, void* extra )
 {
           Error  err;
@@ -519,7 +519,7 @@
          VG_UMSG("");
          stopping_message = True;
       }
-      return;
+      return ERROR_IS_IGNORED_DUE_TO_LIMIT;
    }
 
    /* After M_COLLECT_ERRORS_SLOWLY_AFTER different errors have
@@ -565,8 +565,7 @@
             p->next      = errors;
             errors       = p;
 	 }
-
-         return;
+         return p->supp ? ERROR_IS_SUPPRESSED : ERROR_IS_IGNORED_AS_DUPLICATE;
       }
       p_prev = p;
       p      = p->next;
@@ -624,9 +623,11 @@
       is_first_shown_context = False;
       n_errs_shown++;
       do_actions_on_error(p, /*allow_db_attach*/True);
+      return ERROR_IS_RECORDED;
    } else {
       n_errs_suppressed++;
       p->supp->count++;
+      return ERROR_IS_SUPPRESSED;
    }
 }
 
