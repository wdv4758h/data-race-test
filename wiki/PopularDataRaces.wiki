#summary Description of some most popular data races

<wiki:toc max_depth="1" />

= Simple race = 

A simplest possible data race is the most frequent one: two threads are accessing a variable of a
built-in type without any synchronization.
Quite frequently, such races are benign (the code counts some statistics which is allowed to be imprecise).

{{{
int var;

void Thread1() {  // Runs in one thread.
  var++;
}
void Thread2() {  // Runs in another thread.
  var++;
}

}}}

But sometimes such races are extremely harmful (e.g. if `var` is counting your money :).

==Thread-hostile reference counting==
A variation of race on integer. 
Very harmful. 
May lead to occasional memory leaks or double deletes.

See http://crbug.com/15577 for a real life example.
{{{
// Ref() and Unref() may be called from several threads.
// Last Unref() destroys the object.
class RefCountedObject {
 ...
 public:
  void Ref() {
	ref_++;  // Bug! 
  }
  void Unref() {
	if (--ref_ == 0)  // Bug! Need to use atomic decrement!
	  delete this;
  }
 private:
  int ref_;
};
}}}


=Race on a complex object=

Another popular race happens when two threads access a non-thread-safe complex object
(e.g. an STL container) without synchronization. These are almost always dangerous.

{{{
std::map<int,int> m;

void Thread1() {
  m[123] = 1;
}

void Thread2() {
  m[345] = 0;
}
}}}


= Notification =

Consider the following code:
{{{
bool done = true;

void Thread1() {
  while (!done) {
    do_something_useful_in_a_loop_1();
  } 
  do_thread1_cleanup();
}

void Thread2() {
  do_something_useful_2();
  done = true;
  do_thread2_cleanup();
}
}}}

The synchronization between these two threads is done using a boolean variable `done`.
This is a wrong way to synchronize two threads.

On x86, the biggest issue is the compile-time optimizations.<br/>
  * Part of the code of do_something_useful_2() can be moved below "done = true" by the compiler.
  * Part of the code of do_thread2_cleanup() can be moved above "done = true" by the compiler.
  * If do_something_useful_in_a_loop_1() doesn't modify "done", the compiler may re-write Thread1 in the following way:
{{{
  if (!done) {
    while(true) {
      do_something_useful_in_a_loop_1();
    } 
  }
  do_thread1_cleanup();
}}}
so Thread1 will never exit.

On architectures other than x86, the cache effects or out-of-order instruction execution may lead to other subtle problems.

Most race detector will detect such race.<br/>
Also, most dynamic race detectors will report data races on the memory accesses that were intended to be synchronized with this bool<br/>
(i.e. between do_something_useful_2() and do_thread1_cleanup())

To fix such race you need to use compiler and/or memory barriers (if you are not an expert -- simply use locks).<br/>
It is highly recommended to wrap such a synchronization into a separate class (i.e. ExitNotification) and make it race detector-friendly (i.e. [http://code.google.com/p/data-race-test/wiki/DynamicAnnotations annotate]).

= Publishing objects without synchronization =
One thread initializes an object pointer (which was initially null)
with a new value, another thread spins until the object pointer becomes non-null.
Without proper synchronization, the compiler may do very surprising
transformations with such code which will lead to (occasional) failures.
In addition to that, on some architectures this race may cause failures due
to cache-related effects.

{{{
MyType* obj = NULL;

void Thread1() {
  obj = new MyType();
}

void Thread2() {
  while(obj == NULL)
    yield();
  obj->DoSomething();
}
}}}


=Initializing objects without synchronization=

This may lead e.g. to memory leaks (the object was constructed twice).
{{{
static MyObj *obj = NULL;

void InitObj() { 
  if (!obj) 
    obj = new MyObj(); 
}

void Thread1() {
  InitObj();
}

void Thread2() {
  InitObj();
}
}}}

=Reader Lock during a write=

Updates happening under a reader lock.
{{{
void Thread1() {
  mu.ReaderLock();
  var++;
  mu.ReaderUnlock();
}

void Thread1() {
  mu.ReaderLock();
  var++;
  mu.ReaderUnlock();
}
}}}



= Race on bit field=
The code below looks correct from the first glance.
But if `x` is `struct { int a:4, b:4; }`, we have a bug.
{{{
void Thread1() {
  x.a++;
}

void Thread2() {
  x.b++;
}
}}}



=Double-checked locking=
The so called doubled-checked locking is well know to be an anti-pattern,
but we still find it occasionally.

{{{
bool inited = false;
void Init() {
  // May be called by multiple threads.
  if (!inited) {
    mu.Lock();
    if (!inited) {
      // .. initialize something
    }
    inited = true;
    mu.Unlock();
  }
}
}}}


=Race during destruction=
Sometimes objects are created on stack, passed to another thread and
then destroyed without waiting for the second thread to finish its work.

{{{
void Thread1() {
  SomeType object;
  ExecuteCallbackInThread2(
    SomeCallback, &object);
  ...
  // "object" is destroyed when
  // leaving its scope.
}
}}}

= Data race on vptr =

Class `A` has a function `Done()`,
virtual function `F()` and a virtual destructor.
The destructor waits for the event generated by `Done()`.
There is also a class `B`, which inherits `A` and overrides `A::F()`.

{{{
class A {
 public:
  A() {
   sem_init(&sem_, 0, 0);
  }
  virtual void F() {
   printf ("A::F\n");
  }
  void Done() {
   sem_post(&sem_);
  }
  virtual ~A() {
   sem_wait(&sem_);
   sem_destroy(&sem_);
  }
 private:
  sem_t sem_;
};

class B : public A {
 public:
  virtual void F() {
   printf("B::F\n");
  }
  virtual ~B() { }
};

static A *obj = new B;
}}}

An object `obj` of static type `A` and dynamic type `B` is created. 
One thread executes `obj->F()` and then signals to the second thread.
The second thread calls `delete obj` (i.e. `B::~B`) 
which then calls `A::~A`, which, in turn, waits for the signal from 
the first thread.
The destructor `A::~A` overwrites the vptr (pointer to virtual function table) to
`A::vptr`.
So, if  the first thread executes `obj->F()` after the 
second thread started executing `A::~A`, then `A::F` will be called instead of `B::F`.

{{{
void Thread1() {
  obj->F();
  obj->Done();
}

void Thread1() {
  delete obj;
}
}}}


Consider not using any synchronization in constructors/destructors if the class has virtual methods. Use `Start()` and `Join()` methods instead.

This data race is benign if you don't subclass the class which does synchronization in constructor/destructor.<br/>
In this case, consider [http://www.google.com/search?q=sealed+C%2B%2B sealing] your class 
and annotating the race as benign in the constructor (e.g. `ANNOTATE_BENIGN_RACE(this, "Benign race on vfptr")`).
