#summary Description of some most popular data races

= Non-atomic variable used for synchronization =

===Example===
Consider the following code:
{{{
bool done = true;

void Thread1() {
  while (!done) {
    do_something_useful_in_a_loop_1();
  } 
  do_thread1_cleanup();
}

void Thread2() {
  do_something_useful_2();
  done = true;
  do_thread2_cleanup();
}
}}}

The synchronization between these two threads is done using "done" boolean variable.
However, it is a wrong way to synchronize two threads.

===Description===
On x86, the biggest issue is the compile-time optimizations.<br/>
  * Part of the code of do_something_useful_2() can be moved below "done = true" by the compiler.
  * Part of the code of do_thread2_cleanup() can be moved above "done = true" by the compiler.
  * If do_something_useful_in_a_loop_1() doesn't modify "done", the compiler may re-write Thread1 the following way:
{{{
  if (!done) {
    while(true) {
      do_something_useful_in_a_loop_1();
    } 
  }
  do_thread1_cleanup();
}}}
  so Thread1 will never exit.

On architectures other than x86, the cache effects or out-of-order instruction execution may lead to even bigger problems.

===Detectability===
To our knowledge, almost every data race detector would detect such a data race.<br/>
Also, most dynamic race detectors will report data races on the memory accesses that were intended to be synchronized during development<br/>
(i.e. between do_something_useful_2() and do_thread1_cleanup())

===Fixing===
Fixing such a data race requires introducing compiler/memory barrier on x86/other architectures, respectively.<br/>
It is highly recommended to wrap such a synchronization into a separate class (i.e. ExitNotification) and make it race detector-friendly (e.g. [http://code.google.com/p/data-race-test/wiki/DynamicAnnotations annotate]).

= Publishing objects without synchronization =
===Example===
{{{
class Type {
 public:
  Type() {
    data_ = 7777;
  }
  void DoSomething() {
    assert(data_ == 7777);
  }
 private:
  int data_;
};

Type* obj = NULL;

void Thread1() {
  obj = new Type();
}

void Thread2() {
  while(obj == NULL)
    yield();
  obj->DoSomething();
}
}}}

`Thread2` assumes that once `obj != NULL` holds, the object is constructed and ready to use.

===Description===
This code is very fragile. Its behaviour depends on the compiler and hardware implementation.

For example, `obj = new Type();` line may be compiled/optimized like this:
{{{
obj = malloc(sizeof(Type));
// obj != NULL !!!
obj->data_ = 7777;  // inlining happened
}}}
so Thread2 may exit the while loop before `obj` is constructed.

With real compilers the things are a bit more difficult.

On architectures other than x86, the cache effects or out-of-order instruction execution may lead to even bigger problems. 

===Detectability===
The data race is likely to be reported the same way your data race detection tool reports data races on basic types.

Also, most data race detectors will report data races on the data of `Type` accessed in `DoSomething`.

===Fixing===
Add synchronization using mutex and/or condvar.