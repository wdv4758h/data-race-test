#summary Description of some most popular data races

<wiki:toc max_depth="1" />

= Simple race = 

A simplest possible data race is the most frequent one: two threads are accessing a variable of a
built-in type without any synchronization.
Quite frequently, such races are benign (the code counts some statistics which is allowed to be imprecise).

{{{
int var;

void Thread1() {  // Runs in one thread.
  var++;
}
void Thread2() {  // Runs in another thread.
  var++;
}

}}}

But sometimes such races are extremely harmful (e.g. if `var` is counting your money :).


=Race on a complex object=

Another popular race happens when two threads access a non-thread-safe complex object
(e.g. an STL container) without synchronization. These are almost always dangerous.

{{{
std::map<int,int> m;

void Thread1() {
  m[123] = 1;
}

void Thread2() {
  m[345] = 0;
}
}}}


= Notification =

Consider the following code:
{{{
bool done = true;

void Thread1() {
  while (!done) {
    do_something_useful_in_a_loop_1();
  } 
  do_thread1_cleanup();
}

void Thread2() {
  do_something_useful_2();
  done = true;
  do_thread2_cleanup();
}
}}}

The synchronization between these two threads is done using a boolean variable `done`.
This is a wrong way to synchronize two threads.

On x86, the biggest issue is the compile-time optimizations.<br/>
  * Part of the code of do_something_useful_2() can be moved below "done = true" by the compiler.
  * Part of the code of do_thread2_cleanup() can be moved above "done = true" by the compiler.
  * If do_something_useful_in_a_loop_1() doesn't modify "done", the compiler may re-write Thread1 in the following way:
{{{
  if (!done) {
    while(true) {
      do_something_useful_in_a_loop_1();
    } 
  }
  do_thread1_cleanup();
}}}
so Thread1 will never exit.

On architectures other than x86, the cache effects or out-of-order instruction execution may lead to other subtle problems.

Most race detector will detect such race.<br/>
Also, most dynamic race detectors will report data races on the memory accesses that were intended to be synchronized with this bool<br/>
(i.e. between do_something_useful_2() and do_thread1_cleanup())

To fix such race you need to use compiler and/or memory barriers (if you are not an expert -- simply use locks).<br/>
It is highly recommended to wrap such a synchronization into a separate class (i.e. ExitNotification) and make it race detector-friendly (i.e. [http://code.google.com/p/data-race-test/wiki/DynamicAnnotations annotate]).

= Publishing objects without synchronization =
One thread initializes an object pointer (which was initially null)
with a new value, another thread spins until the object pointer becomes non-null.
Without proper synchronization, the compiler may do very surprising
transformations with such code which will lead to (occasional) failures.
In addition to that, on some architectures this race may cause failures due
to cache-related effects.

{{{
MyType* obj = NULL;

void Thread1() {
  obj = new MyType();
}

void Thread2() {
  while(obj == NULL)
    yield();
  obj->DoSomething();
}
}}}


=Initializing objects without synchronization=

This may lead e.g. to memory leaks (the object was constructed twice).
{{{
static MyObj *obj = NULL;

void InitObj() { 
  if (!obj) 
    obj = new MyObj(); 
}

void Thread1() {
  InitObj();
}

void Thread2() {
  InitObj();
}
}}}

=Reader Lock during a write=

Updates happening under a reader lock.
{{{
void Thread1() {
  mu.ReaderLock();
  var++;
  mu.ReaderUnlock();
}

void Thread1() {
  mu.ReaderLock();
  var++;
  mu.ReaderUnlock();
}
}}}



= Race on bit field=
The code below looks correct from the first glance.
But if `x` is `struct { int a:4, b:4; }`, we have a bug.
{{{
void Thread1() {
  x.a++;
}

void Thread2() {
  x.b++;
}
}}}


= Data race on virtual functions table pointer (vfptr) =

===Example===
Suppose we have a `Thread` class with `Start()`, `Join()` and `Run()` methods (like in Java).

Consider the following code:
{{{
class ParentClass: public Thread {
public:
  ParentClass() {
    // (1)
    Thread::Start();
  }

  ~ParentClass() {
    // (2)
    Thread::Join();
  }

  virtual void SomeMethod() {
    do_something_useful_1();
  }

  virtual void Run() {
    do_something_useful_2();
    SomeMethod();
    do_something_useful_3();
  }
};

class MyClass : public ParentClass {
public:
  MyClass() {
    // (3)
  }

  ~MyClass() {
    // (4)
  }

  virtual void SomeMethod() {
    do_something_useful_4();
  }
}
}}}

There is a data race on `vfptr` in this example.

===Description===
Let's consider an instance of `MyClass`.<br/>
The C++ standard doesn't specify the exact places where `vfptr` is set.
`gcc` sets `vfptr` to the value of `vfptr` of the current class when entering a constructor/destructor. <br/>
`vfptr` will point to `ParentClass vfptr` at code points `(1)` and `(2)`. <br/>
`vfptr` will point to `MyClass vfptr` only between entering `MyClass`  constructor `(3)` and leaving `MyClass` destructor `(4)`.<br/>

As a result, calling `SomeMethod()` from a thread started/joined by `ParentClass` may result in calling *either* `ParentClass:SomeMethod()` *or* `MyClass::SomeMethod`. 
Also, this may case a pure-virtual call if `ParentClass::SomeMethod()` is defined as pure-virtual.

A similar data race can happen if you use other means of synchronization (Mutex, !CondVar, etc) in the class constructor/destructor.

===Fixing===
Consider not using any synchronization in constructors/destructors if the class has virtual methods. Use `Start()` and `Join()` methods instead.

The data race is benign if you don't subclass the class which does synchronization (e.g. thread creation and joining) in constructor/destructor.<br/>
In this case, consider [http://www.google.com/search?q=sealed+C%2B%2B sealing] your class and annotating the race as benign in the constructor (e.g. `ANNOTATE_BENIGN_RACE(this, "Benign race on vfptr")`).
