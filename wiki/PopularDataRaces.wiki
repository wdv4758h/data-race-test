#summary Description of some most popular data races

<wiki:toc max_depth="1" />

= Non-atomic variable used for synchronization =

===Example===
Consider the following code:
{{{
bool done = true;

void Thread1() {
  while (!done) {
    do_something_useful_in_a_loop_1();
  } 
  do_thread1_cleanup();
}

void Thread2() {
  do_something_useful_2();
  done = true;
  do_thread2_cleanup();
}
}}}

The synchronization between these two threads is done using "done" boolean variable.
However, it is a wrong way to synchronize two threads.

===Description===
On x86, the biggest issue is the compile-time optimizations.<br/>
  * Part of the code of do_something_useful_2() can be moved below "done = true" by the compiler.
  * Part of the code of do_thread2_cleanup() can be moved above "done = true" by the compiler.
  * If do_something_useful_in_a_loop_1() doesn't modify "done", the compiler may re-write Thread1 the following way:
{{{
  if (!done) {
    while(true) {
      do_something_useful_in_a_loop_1();
    } 
  }
  do_thread1_cleanup();
}}}
  so Thread1 will never exit.

On architectures other than x86, the cache effects or out-of-order instruction execution may lead to even bigger problems.

===Detectability===
To our knowledge, almost every data race detector would detect such a data race.<br/>
Also, most dynamic race detectors will report data races on the memory accesses that were intended to be synchronized during development<br/>
(i.e. between do_something_useful_2() and do_thread1_cleanup())

===Fixing===
Fixing such a data race requires introducing compiler/memory barrier on x86/other architectures, respectively.<br/>
It is highly recommended to wrap such a synchronization into a separate class (i.e. ExitNotification) and make it race detector-friendly (e.g. [http://code.google.com/p/data-race-test/wiki/DynamicAnnotations annotate]).

= Publishing objects without synchronization =
===Example===
{{{
class Type {
 public:
  Type() {
    data_ = 7777;
  }
  void DoSomething() {
    assert(data_ == 7777);
  }
 private:
  int data_;
};

Type* obj = NULL;

void Thread1() {
  obj = new Type();
}

void Thread2() {
  while(obj == NULL)
    yield();
  obj->DoSomething();
}
}}}

`Thread2` assumes that once `obj != NULL` holds, the object is constructed and ready to use.

===Description===
This code is very fragile. Its behaviour depends on the compiler and hardware implementation.

For example, `obj = new Type();` line may be compiled/optimized like this:
{{{
obj = malloc(sizeof(Type));
// obj != NULL !!!
obj->data_ = 7777;  // inlining happened
}}}
so Thread2 may exit the while loop before `obj` is constructed.

With real compilers the things are a bit more difficult.

On architectures other than x86, the cache effects or out-of-order instruction execution may lead to even bigger problems. 

===Detectability===
The data race is likely to be reported the same way your data race detection tool reports data races on basic types.

Also, most data race detectors will report data races on the data of `Type` accessed in `DoSomething`.

===Fixing===
Add synchronization using mutex and/or condvar.

= Data race on virtual functions table pointer (vfptr) =

===Example===
Suppose we have a `Thread` class with `Start()`, `Join()` and `Run()` methods (like in Java).

Consider the following code:
{{{
class ParentClass: public Thread {
public:
  ParentClass() {
    // (1)
    Thread::Start();
  }

  ~ParentClass() {
    // (2)
    Thread::Join();
  }

  virtual void SomeMethod() {
    do_something_useful_1();
  }

  virtual void Run() {
    do_something_useful_2();
    SomeMethod();
    do_something_useful_3();
  }
};

class MyClass : public ParentClass {
public:
  MyClass() {
    // (3)
  }

  ~MyClass() {
    // (4)
  }

  virtual void SomeMethod() {
    do_something_useful_4();
  }
}
}}}

There is a data race on `vfptr` in this example.

===Description===
Let's consider an instance of `MyClass`.<br/>
The C++ standard doesn't specify the exact places where `vfptr` is set.
`gcc` sets `vfptr` to the value of `vfptr` of the current class when entering a constructor/destructor. <br/>
`vfptr` will point to `ParentClass vfptr` at code points `(1)` and `(2)`. <br/>
`vfptr` will point to `MyClass vfptr` only between entering MyClass constructor `(3)` and leaving MyClass destructor `(4)`.<br/>

As a result, calling `SomeMethod()` from a thread started/joined by `ParentClass` may result in calling *either* `ParentClass:SomeMethod()` *or* `MyClass::SomeMethod`. 
Also, this may case a pure-virtual call if `ParentClass::SomeMethod()` is defined as pure-virtual.

A similar data race can happen if you use other means of synchronization (Mutex, !CondVar, etc) in the class constructor/destructor.

===Fixing===
Consider not using any synchronization in constructors/destructors. Use `Start()` and `Join()` methods instead.

The data race is benign if you don't subclass the class which does synchronization (e.g. thread creation and joining) in constructor/destructor.<br/>
In this case, consider [http://www.google.com/search?q=sealed+C%2B%2B sealing] your class and annotating the race as benign in the constructor (e.g. `ANNOTATE_BENIGN_RACE(this, "Benign race on vfptr")`).