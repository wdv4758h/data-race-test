#summary ThreadSanitize for Go


= Introduction =

We want to make ThreadSanitizer work for the [http://golang.org/ Go language]


= Tests =

We have few unit tests for Go. 

  * Install [http://golang.org/doc/gccgo_install.html gccgo] (if not yet)
  * Install ThreadSanitizer (if not yet)
  * Get and build the unittests: 
{{{
svn checkout http://data-race-test.googlecode.com/svn/trunk/go_tests
cd go_tests
make
}}}
  * Run individual tests under ThreadSanitizer: 
{{{
tsan --fast-mode=no --ignore=./go.ignore --file-prefix-to-cut=go_tests/ ./test_name
}}}

== go_race_1 ==
http://code.google.com/p/data-race-test/source/browse/trunk/go_tests/go_race_1.go

{{{
tsan --fast-mode=no --ignore=./go.ignore --file-prefix-to-cut=go_tests/ ./go_race_1
}}}

{{{
==27892== WARNING: Possible data race during read of size 4 at 0x668E50: {{{
==27892==    T2 (locks held: {}):
==27892==     #0  main.inc go_race_1.go:24
==27892==     #1  main.Thread2 go_race_1.go:37
==27892==     #2  start_go_thread /home/kcc/objdir/x86_64-unknown-linux-gnu/libgo/../../../gccgo/libgo/runtime/go-go.c:39
==27892==     #3  ThreadSanitizerStartThread ts_valgrind_intercepts.c:525
==27892==   Concurrent write(s) happened at (OR AFTER) these points:
==27892==    T1 (locks held: {}):
==27892==     #0  main.inc go_race_1.go:22
==27892==     #1  main.Thread1 go_race_1.go:30
==27892==     #2  start_go_thread /home/kcc/objdir/x86_64-unknown-linux-gnu/libgo/../../../gccgo/libgo/runtime/go-go.c:39
==27892==     #3  ThreadSanitizerStartThread ts_valgrind_intercepts.c:525
==27892==   Address 0x668E50 is 0 bytes inside data symbol "main.racey"
==27892== }}}
}}}

There is a race in this test indeed, but the locks are not recognized and not printed.


== go_race_2 ==
http://code.google.com/p/data-race-test/source/browse/trunk/go_tests/go_race_2.go

Same as go_race_1, but with `RWMutex`

== go_norace_1 ==
http://code.google.com/p/data-race-test/source/browse/trunk/go_tests/go_norace_1.go

{{{
tsan --fast-mode=no --ignore=./go.ignore --file-prefix-to-cut=go_tests/ ./go_norace_1
}}}

{{{
==28234== WARNING: Possible data race during read of size 4 at 0x668E48: {{{
==28234==    T2 (locks held: {}):
==28234==     #0  main.inc go_norace_1.go:23
==28234==     #1  main.Thread2 go_norace_1.go:35
==28234==     #2  start_go_thread /home/kcc/objdir/x86_64-unknown-linux-gnu/libgo/../../../gccgo/libgo/runtime/go-go.c:39
==28234==     #3  ThreadSanitizerStartThread ts_valgrind_intercepts.c:525
==28234==   Concurrent write(s) happened at (OR AFTER) these points:
==28234==    T1 (locks held: {}):
==28234==     #0  main.inc go_norace_1.go:21
==28234==     #1  main.Thread1 go_norace_1.go:28
==28234==     #2  start_go_thread /home/kcc/objdir/x86_64-unknown-linux-gnu/libgo/../../../gccgo/libgo/runtime/go-go.c:39
==28234==     #3  ThreadSanitizerStartThread ts_valgrind_intercepts.c:525
==28234==   Address 0x668E48 is 0 bytes inside data symbol "main.obj"
==28234== }}}
}}}

The code is synchronized via a channel, but ThreadSanitizer does not know about channels. 
== go_norace_2 ==
http://code.google.com/p/data-race-test/source/browse/trunk/go_tests/go_norace_2.go
{{{
tsan --fast-mode=no --ignore=./go.ignore --file-prefix-to-cut=go_tests/ ./go_norace_2
}}}

{{{
==28602==    T2 (locks held: {}):
==28602==     #0  main.inc go_norace_2.go:23
==28602==     #1  main.Thread2 go_norace_2.go:36
==28602==     #2  start_go_thread /home/kcc/objdir/x86_64-unknown-linux-gnu/libgo/../../../gccgo/libgo/runtime/go-go.c:39
==28602==     #3  ThreadSanitizerStartThread ts_valgrind_intercepts.c:525
==28602==   Concurrent write(s) happened at (OR AFTER) these points:
==28602==    T1 (locks held: {}):
==28602==     #0  main.inc go_norace_2.go:21
==28602==     #1  main.Thread1 go_norace_2.go:29
==28602==     #2  start_go_thread /home/kcc/objdir/x86_64-unknown-linux-gnu/libgo/../../../gccgo/libgo/runtime/go-go.c:39
==28602==     #3  ThreadSanitizerStartThread ts_valgrind_intercepts.c:525
==28602==   Address 0x668E48 is 0 bytes inside data symbol "main.obj"
==28602== }}}
}}}

The code is synchronized via a Mutex, but ThreadSanitizer does not understand the go Mutex. 