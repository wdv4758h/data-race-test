#summary Examples of common High-Level Data Races.

= Definitions and types of High-Level Data Races =

*TODO* High-Level Data Race - potential dangerous concurrent code without regular data races.  
[http://code.google.com/p/data-race-test/wiki/RaceDetectionLinks#High-Level_Data_Races Links] to articles about HL data races detection.

*Atomicity* - also called as *serializability*, is a property for the concurrent execution of several operations when their data manipulation effect is equivalent to that of a serial execution of them.  The assumed atomicity can be broken when the code region is unserializably interleaved by accesses from another thread, which leads to an *atomicity violation bug*. _S. Lu, J. Tucek, F. Qin, and Y. Zhou. AVIO: Detecting atomicity violations via access interleaving invariants. In ASPLOS, 2006._

The basic type of *unserializable interleavings* is composed of three memory accesses. Two of them, referred to as p(receding)-access and c(urrent)-access, consecutively access a shared location from the same thread. The third one, referred to as r(emote)-access, accesses the same memory location in the middle of the previous two from a different thread. Unserializable interleaving space gives a good coverage for all potential atomicity violation bugs. _S. Park, S. Lu, and Y. Zhou. Ctrigger: exposing atomicity violation bugs from their hiding places. In Fourteenth International Conference on Architec- ture Support for Programming Languages and Op- erating Systems (ASPLOS ’09), pages 25–36, Mar. 2009._

*Multi-Variable Race*. There are correlated variables e.g. field of one object, describe same side of object. We can widen definition of data race from memory accesses to single instance to set of correlated instances.

= Examples =

== First motivational example ==

Consider following *java* source

{{{

private int uk;
private int[] stack;

synchronized int getSize() {
  return uk;
}

synchronized void put(int x) {
  stack[uk++] = x;
}

synchronized int push() {
  return stack[--uk];
}

thread1() {
  for (int i=0; i<10; i++) {
    put(i);
  }
  while (getSize()) > 0) {
    // BAD BAD BAD
    push();
  } 
}

thread2() {
  thread1();
}

}}}

We havn't tradition data race, but code is unsafe.

== Inconsistent state ==

Following example take from [http://staff.aist.go.jp/c.artho/papers/vveis03.pdf this paper]. Main idea: we have complicated object with several propertis. And we have several methods to prompt it to other state. Than, without explicit synchronization we can get inconsistent state of this object.

Example:

{{{

class Point {
  private int x, y;
  public Point() {
    x = 0;
    y = 0;
  }
  // getter and setter for X
  public synchronized int getX() {
    return x;
  }
  public synchronized void setX(int nx) {
    x = nx;
  }
  // getter and setter for Y
  ...
  // getter and setter for X and Y
  public synchronized int[] getXY() {
    return new int[] {x, y};
  }
  public synchronized void setXY(int nx, int ny) {
    x = nx;
    y = ny;
  }

}

Point global_p;

thread1() {
  global_p = new Point();
  global_p.setX(100);
  // BAD BAD BAD
  global_p.setY(100);
}

thread2() {
  Point local_p = new Point();
  int[] xy = gloabal_p.getXY();
  local_p.setXY(xy[0], xy[1]);  
}

}}} 

== Apache Con-Overflow ==

Example from [http://pages.cs.wisc.edu/~shanlu/paper/asplos184-zhang.pdf ConMem paper]. A concurrent bug that can lead to buffer overflow and crash (from Apache-2.0.45)

{{{
thread1:
if ( buf−−>cnt + len > LOG_SIZE ) {
...
}else {
memcpy (&buf[buf−−>cnt], str, len);
...

thread2:
buf−>cnt += len;


// buf−>cnt is a shared variable that
// represents the current index of a buffer.

}}}