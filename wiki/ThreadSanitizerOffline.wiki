#summary Experimental offline race detector

=ThreadSanitizer offline=
We have an experimental offline race detector. 
It does not depend on any binary instrumentation framework. 
Instead, it simply reads events from a text file. 
Currently, the only supported event syntax mimics 
the events generated by Valgrind-based ThreadSanitizer (see [http://code.google.com/p/data-race-test/source/browse/trunk/tsan/offline_tests/simple_race_1.tst simple_race_1.tst]), but we can 
support any syntax we need. 

This is all experimental, don't expect anything here to be really usable (yet).

== How to try == 
Get, build and run ThreadSanitizerOffline:
{{{
svn co   http://data-race-test.googlecode.com/svn/trunk/tsan
cd tsan 
make -j  -f ts_makefile 
./ts_offline  --fast-mode=no --show_pc    < offline_tests/simple_race_1.tst
}}}

If you are lucky, you may get the following output: 
{{{
INFO: ThreadSanitizerOffline
==30181== INFO: Allocating 939524096 (112 * 8388608) bytes for Segments.
==30181== INFO: T1 has been created by T0. Use --announce-threads to see the creation stack.
==30181== INFO: T0 is program's main thread
==30181== WARNING: Possible data race during read of size 1 at 0xabcde: {{{
==30181==    T1 (writer locks held: {}; reader locks held: {L2}):
==30181==     #0  0xaa108001:
==30181==     #1  0xca100002:
==30181==     #2  0xca100001:
==30181==   Concurrent write(s) happened at (OR AFTER) these points:
==30181==    T0 (locks held: {L1}):
==30181==     #0  0xca000003:
==30181==     #1  0xca000002:
==30181==     #2  0xca000001:
==30181==   Location 0xabcde is 14 bytes inside a block starting at 0xabcd0 of size 255 allocated by T0 from heap:
==30181==     #0  0xcdeffedc:
==30181==     #1  0xca000002:
==30181==     #2  0xca000001:
==30181==   Locks involved in this report (reporting last lock sites): {L1, L2}
==30181==    L1
==30181==     #0  0xaa:
==30181==     #1  0xca000002:
==30181==     #2  0xca000001:
==30181==    L2
==30181==     #0  0xbb:
==30181==     #1  0xca100002:
==30181==     #2  0xca100001:
==30181== }}}
}}}

And a more interesting test (events are dumped from a real program): 
{{{
zcat offline_tests/301.tst.gz |  ./ts_offline | c++filt
}}}

{{{
INFO: ThreadSanitizerOffline
==12559== INFO: Allocating 939524096 (112 * 8388608) bytes for Segments.
==12559== INFO: T1 has been created by T0. Use --announce-threads to see the creation stack.
==12559== INFO: T2 has been created by T0. Use --announce-threads to see the creation stack.
==12559== WARNING: Possible data race during write of size 4 at 0x63f7e0: {{{
==12559==    T2 (locks held: {L130}):
==12559==     #0  test301::Thread2() racecheck_unittest.cc:7050
==12559==     #1  MyThread::ThreadBody(MyThread*) thread_wrappers_pthread.h:325
==12559==     #2  start_thread /usr/grte/v1/lib64/libpthread.so.0
==12559==   Concurrent write(s) happened at (OR AFTER) these points:
==12559==    T1 (locks held: {L129}):
==12559==     #0  test301::Thread1() racecheck_unittest.cc:7045
==12559==     #1  MyThread::ThreadBody(MyThread*) thread_wrappers_pthread.h:325
==12559==     #2  start_thread /usr/grte/v1/lib64/libpthread.so.0
==12559==   Locks involved in this report (reporting last lock sites): {L129, L130}
==12559==    L129
==12559==     #0  __pthread_mutex_lock_internal /usr/grte/v1/lib64/libpthread.so.0
==12559==     #1  MutexLock::MutexLock(Mutex*) thread_wrappers.h:277
==12559==     #2  test301::Thread1() racecheck_unittest.cc:7044
==12559==     #3  MyThread::ThreadBody(MyThread*) thread_wrappers_pthread.h:325
==12559==     #4  start_thread /usr/grte/v1/lib64/libpthread.so.0
==12559==    L130
==12559==     #0  __pthread_mutex_lock_internal /usr/grte/v1/lib64/libpthread.so.0
==12559==     #1  MutexLock::MutexLock(Mutex*) thread_wrappers.h:277
==12559==     #2  test301::Thread2() racecheck_unittest.cc:7049
==12559==     #3  MyThread::ThreadBody(MyThread*) thread_wrappers_pthread.h:325
==12559==     #4  start_thread /usr/grte/v1/lib64/libpthread.so.0
==12559== }}}
}}}