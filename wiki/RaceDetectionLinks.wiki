#summary Links related to race detection

= Please HELP!!! =

Reader, we need your help!
We want to collect an exhaustive and well annotated list of links to all materials related to race detection. 

== Race detectors == 

  * Intel Thread Checker
    * Pure happens-before race detector, available on both Windows and Linux
    * Supports annotations (*TODO*: find a link to help/manual!)
    * Supports both compile-time and run-time instrumentation
    * A couple of papers are available:
      # [http://portal.acm.org/citation.cfm?id=1147416 U. Banerjee, B. Bliss, Z. Ma, and P. Petersen - A theory of data race detection]
      # [http://software.intel.com/file/6311 U. Banerjee, B. Bliss, Z. Ma, and P. Petersen - Unraveling Data Race Detection in the IntelÂ® Thread Checker]
    * [http://software.intel.com/en-us/intel-thread-checker/ Product homepage]
    * Available for download the Linux version for noncommercial use
  * Sun Thread Analyzer
    * Hyrbid race detector, available on Solaris, SuSE Linux Enterprise Server 9 and the Red Hat Enterprise Linux 4
    * Supports annotations ([http://developers.sun.com/sunstudio/downloads/tha/tha_using.html#User%20APIs documentation])
    * Requires compile-time instrumentation
    * TODO: download site, link to paper (any available?), comments
  * Helgrind
    * Pure happens-before race detector (since 3.4), available on Linux and Mac
    * Doesn't support annotations (as of August 14, work in progress)
    * Based on Valgrind run-time instrumentation framework
    * Open sourced as a part of Valgrind ([http://valgrind.org/downloads/ download], [http://valgrind.org/docs/manual/hg-manual.html manual])
    * TODO: paper (any available?), comments
  * DRD
    * Pure happens-before race detector, available on Linux and Mac
    * Annotations are (partly?) supported (as of August 14, work in progress)
    * Based on Valgrind run-time instrumentation framework
    * Open sourced as a part of Valgrind ([http://valgrind.org/downloads/ download], [http://valgrind.org/docs/manual/drd-manual.html manual])
    * TODO: paper (any available?), comments
  * MTRAT/MSDK: http://www.alphaworks.ibm.com/tech/msdk
    * IBM's Race detector for Java
    * Article: http://portal.acm.org/citation.cfm?doid=1639622.1639627
  * Lamport's paper
    * [http://portal.acm.org/citation.cfm?id=359563 L. Lamport, Time, clocks, and the ordering of events in a distributed system]
    * TODO: link to a paper
  * Eraser
    * Lockset-based race detector
    * [http://portal.acm.org/citation.cfm?id=265927 S. Savage , M. Burrows , G. Nelson , P. Sobalvarro, T. Anderson - Eraser: a dynamic data race detector for multithreaded programs]
    * TODO: comments
  * ThreadSanitizer: valgrind-based race detector. Supports both hybrid and pure happens-before modes. 
    * Supports both hybrid and pure happens-before modes, available on Linux and Mac
    * Support annotations
    * Based on Valgrind run-time instrumentation framework
    * Open sourced ([http://code.google.com/p/data-race-test/wiki/ThreadSanitizer download instructions, manual])
    * Paper presented at [http://www.dyninst.org/wbia09/ WBIA'09]: http://pintool.org/wbia09.pdf, pages 62-71.

== Articles on race detection == 
*TODO* (add more)

  * [http://pages.cs.wisc.edu/~shanlu/paper/asplos184-zhang.pdf ConMem: Detecting Severe Concurrency Bugs through an Effect-Oriented Approach]. Wei Zhang, Chong Sun, and Shan Lu. 15th International Conference on Architecture Support for Programming Languages and Operating Systems (ASPLOS'10).
  *  [http://www.cs.washington.edu/homes/luisceze/publications/isca173-lucia.pdf  Conflict Exceptions: Simplifying Concurrent Language Semantics with Precise Hardware Exceptions for Data-Races] -- fast race detection which requires hardware support.
  * [http://slang.soe.ucsc.edu/cormac/papers/pldi10.pdf Adversarial Memory for Detecting Destructive Races] -- automatically checking if a race is benign or harmful.
  * [http://www.usenix.org/events/osdi10/tech/full_papers/Erickson.pdf Effective Data-Race Detection for the Kernel]. John Erickson, Madanlal Musuvathi, Sebastian Burckhardt, and Kirk Olynyk, Microsoft Research. -- Using hardware break points and watch points to detect races at run-time. As ingenious as it is simple!

== General bug-finding links == 

  * http://cacm.acm.org/magazines/2010/2/69354-a-few-billion-lines-of-code-later/fulltext/ -- extremely entertaining reading about the "Coverity" static analysis tool. 
  
== High-Level Data Races ==
*TODO* (Sergey Vorobyev) add about 20 items
  * [http://staff.aist.go.jp/c.artho/papers/vveis03.pdf  High-Level Data Races. Cyrille Artho, Klaus Havelund, Armin Biere] -- continuation Eraser approach. Basic examination object is set of access to variables near lock. Intersect of this sets for same lock produced view of variables - one of basic definition in this paper. Unhappily, this algorithm doesn't help us in [http://code.google.com/p/data-race-test/wiki/HighLevelDataRaces?ts=1280497301&updated=HighLevelDataRaces#First_motivational_example First motivational example]. It's cover [http://code.google.com/p/data-race-test/wiki/HighLevelDataRaces?ts=1280745577&updated=HighLevelDataRaces#Inconsistent_state Inconsistent state]. By the way, article describe high level data-race occurred in NASA spacecraft controller. Algorithm described in Section 3 and occupy only one page. *Large number of false positives* on the real-world applications state in MUVI paper. Implementation name is *Java PathExplorer*.
 
  * [http://web.mit.edu/ralucap/www/MUVI.pdf MUVI: Automatically Inferring Multi-Variable Access Correlations and Detecting Related Semantic and Concurrency Bugs. Shan Lu, Soyeon Park, Chongfeng Hu, Xiao Ma, Weihang Jiang Zhenmin Li, Raluca A. Popa, Yuanyuan Zhou]. Multi-Variable Race Detection. Introduce model of variable correlations basic on static analyse. Defines correlate-metrics in a source code. This approach can auto-determine correlated variables in reasonably mature programs. MUVI can generate annotation for other race detectors. Also develop multi-variable variant of lock-set and happens-before algorithms. Number of *false-positives is comparable with true-bugs* (13 false vs 8 true).
  * [http://parlab.eecs.berkeley.edu/sites/all/parlab/files/Randomized%20Active%20Atomicity%20Violation%20Detection%20in%20Concurrent%20Programs.pdf Randomized Active Atomicity Violation Detection in Concurrent Programs. Chang-Seo Park, Koushik Sen]. Suggest use own randomized scheduler with different seeds. If annotated 'atom' blocks interleaving then report existing atomicity violation. With stored seed it's easy to reproduce violation case. Number of *false-positives is comparable with true-bugs* (7 false vs 14 true). Author's Implementation for Java named *AtomFuzzer* (only prototype). 
  * [http://pages.cs.wisc.edu/~shanlu/paper/asplos092-zhou.pdf CTrigger: Exposing Atomicity Violation Bugs from Their Hiding Places. Soyeon Park, Shan Lu, Yuanyuan Zhou]. Suggest two-phase algorithm to find Unserializable Interleavings. First phase identify target interleavings by 3 steps. Second phase - controlled testing, if exists bug. Generally approach same with _Randomized Active Atomicity Violation Detection in Concurrent Programs_: tricky scheduler. But unlikely previous work, CTrigger can identify potential dangerous regions without annotations, base on definition of Unserializable Interleavings.
  * [http://www.google.ru/url?sa=t&source=web&cd=1&ved=0CBUQFjAA&url=http%3A%2F%2Fciteseerx.ist.psu.edu%2Fviewdoc%2Fdownload%3Fdoi%3D10.1.1.91.1388%26rep%3Drep1%26type%3Dpdf&ei=V7t7TNiZJ47Gswb4z8CyDQ&usg=AFQjCNHYCFY-_AGnRyfY1GmqGDV10sjfrg AVIO: Detecting Atomicity Violations via Access Interleaving Invariants. Shan Lu, Joseph Tucek, Feng Qin and Yuanyuan Zhou]. Like CTrigger main idea of paper is automatically define atomicity regions, named Access Interleaving Invariants. Program running with same input about 100 times. Remember pairs of instruction from same thread without interleaving. And suggest they atomicity. After learning phase, information about atomicity regions can used for finding atomicity violations. Produce *a lot of false-positives* (16 false vs 4 true).
  * [http://www.google.ru/url?sa=t&source=web&cd=1&ved=0CBUQFjAA&url=http%3A%2F%2Fresearch.microsoft.com%2Fen-us%2Fum%2Fpeople%2Fleino%2Fpapers%2Fkrml107.pdf&ei=3xiGTOPEG8q6ONCc6NAO&usg=AFQjCNF7oOz23Zu5Mu4uFMmt2GI5KlZv1Q Finding stale-value errors in concurrent programs. M. Burrows and K. R. M. Leino.] Suggest use instrumentation for add for every local variable _t_ boolean _stale_t_ variable. Support invariant: _stale_t_ is _true_ if and only if the value of _t_ is considered stale. For every read t _assert(!stale_t)_ must passed, over wise we report stale-value error. Also bring in two other subsidiary invariants. Approach has problems with multi-locks and produce *many false-positives* (43 false alarm vs 4 true bugs).
 * [http://www.cs.washington.edu/homes/luisceze/publications/lucia-atomaid.pdf Atom-Aid: Detecting and Surviving Atomicity Violations. Brandon Lucia.] Asseverates typical atomicity violation ranges from 500 to 750 dynamic instructions. Suggest sophisticated united code in chucks size about 2000. Thereby potentially atomicity violation regions are hidden in the same chunk. Chucks executes atomically and in isolation. Based on implicit atomicity systems (BulkSC, Atomic Sequence Ordering, Implicit Transactions).   

== TODO ==
*TODO* add all links we already have somewhere. 

*TODO* find new interesting links.

    