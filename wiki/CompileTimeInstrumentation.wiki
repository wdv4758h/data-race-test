#summary LLVM compile-time instrumentation for TSan support

We've implemented an experimental compile-time instrumentation pass for LLVM that allows us to directly link ThreadSanitizer against the client code instead of using binary instrumentation frameworks.

An instrumented program collects the events (memory accesses, routine calls/exits) and passes it to the runtime library that serves as a proxy between the client code and ThreadSanitizer. The RTL also provides wrappers for functions that ThreadSanitizer should know about (synchronization primitives, allocation routines, [DynamicAnnotations dynamic annotations]

Once the LLVM prototype is finished, the runtime library could be used with other compilers, e.g. gcc.

= Pros and Cons =
Possible advantages:
  * no binary translation and instrumentation overhead at runtime
  * at compile time we know the semantic information that allows us to ignore accesses to thread-local memory (e.g. unescaped stack allocations)

Possible drawbacks:
  * we'll need to recompile libc and other system libraries or somehow hardcode the knowledge about their functions in order to find races on the memory passed to library functions

= Usage and current status =
See the code in http://code.google.com/p/data-race-test/source/browse/#svn/trunk/llvm

Before using the tool you should build the opt plugin and the runtime library:
{{{
cd llvm/opt/ThreadSanitizer
make
cd ../../tsan_rtl
make
}}}

The prerequisites necessary for building ThreadSanitizer.so are listed in `llvm/opt/README`


To compile a small test containing one file:

`$ llvm/scripts/instrument_and_link.sh path/to/program.c` -- produces `path/to/program` binary with builtin ThreadSanitizer

To build a larger program with `make`, use the wrappers for `gcc`/`g++`, `ld`, `ar`.
For example, this is how racecheck_unittest is built:
{{{
make OMIT_CPP0X=1 \
CXXFLAGS="-DDYNAMIC_ANNOTATIONS_WANT_ATTRIBUTE_WEAK \
-DRACECHECK_UNITTEST_WANT_ATTRIBUTE_WEAK" \
CFLAGS="-DDYNAMIC_ANNOTATIONS_WANT_ATTRIBUTE_WEAK \
-DRACECHECK_UNITTEST_WANT_ATTRIBUTE_WEAK" \
CC=`pwd`/../llvm/scripts/gcc.sh \
CXX=`pwd`/../llvm/scripts/gcc.sh LD=`pwd`/../llvm/scripts/ld.sh \
AR=`pwd`/../llvm/scripts/ar.sh l32
}}}

To run the tests, just execute the resulting binary. Additional flags for ThreadSanitizer can be supplied via the TSAN_ARGS env variable. To see function and file names in the race report, the path to .dbg file generated by the instrumentation pass should be supplied via TSAN_DBG_INFO var.

*Note*: at the moment racecheck_unittest doesn't pass when linked against ThreadSanitizer.

= Future development =
  * make racecheck_unittest pass
  * support [ LiteRaceSampling literace sampling ]
  * make less calls from the instrumented program to RTL (do not flush each basic block or each basic block slice between call/invoke instructions)
  * try this on something big (Chromium?)
  * compare the performance with Valgrind- or PIN-based ThreadSanitizer
  * use escape analysis to reduce the number of instrumented operations
  * fill superblock passports while generating the native code to get rid of .dbg files
  * implement *fast* event logging in the RTL for offline mode
  * write a gcc plugin for program instrumentation