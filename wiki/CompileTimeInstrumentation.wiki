#summary LLVM compile-time instrumentation for TSan support

We've implemented an experimental compile-time instrumentation pass for LLVM that allows us to directly link ThreadSanitizer against the client code instead of using binary instrumentation frameworks.

An instrumented program collects the events (memory accesses, routine calls/exits) and passes it to the runtime library that serves as a proxy between the client code and ThreadSanitizer. The RTL also provides wrappers for functions that ThreadSanitizer should know about (synchronization primitives, allocation routines, [DynamicAnnotations dynamic annotations]

Once the LLVM prototype is finished, the runtime library could be used with other compilers, e.g. gcc.

= Pros and Cons =
Possible advantages:
  * no binary translation and instrumentation overhead at runtime
  * at compile time we know the semantic information that allows us to ignore accesses to thread-local memory (e.g. unescaped stack allocations)

Possible drawbacks:
  * we'll need to recompile libc and other system libraries or somehow hardcode the knowledge about their functions in order to find races on the memory passed to library functions

= Usage and current status =
See the code in http://code.google.com/p/data-race-test/source/browse/#svn/trunk/llvm

Before using the tool you should build the opt plugin and the runtime library:
{{{
cd llvm
make
}}}

The prerequisites necessary for building ThreadSanitizer.so are listed in `llvm/opt/README`

To compile a small test containing one file:

`$ llvm/scripts/instrument_and_link.sh [x86|x86_64] path/to/program.c` -- produces `path/to/program` binary with builtin ThreadSanitizer

To build a larger program with `make`, use the wrappers for `gcc` and `g++`.
For example, this is how racecheck_unittest is built:
{{{
make OPT=1 OMIT_DYNAMIC_ANNOTATIONS_IMPL=1 OMIT_CPP0X=1 PATH="`pwd`/../llvm/scripts/:$PATH" EXTRA_BUILD_SUFFIX=-llvm l64
}}}

To run the tests, just execute the resulting binary. Additional flags for ThreadSanitizer can be supplied via the TSAN_ARGS env variable.

*Note*: at the moment racecheck_unittest doesn't pass when linked against ThreadSanitizer.

= How it is done =
The wrappers for `gcc` and `g++` translate C/C++ code into LLVM assembly code using `llvm-gcc`. It is then instrumented using `opt`, which invokes `ThreadSanitizer.so` as a plugin. The instrumented code contains calls to the functions provided by the runtime library. If `gcc`/`g++` is used to link an executable binary, it is additionally linked with the ThreadSanitizer runtime (`tsan_rtl32.a` or `tsan_rtl64.a` depending on the word length)

== Instrumenting the client code ==
Each client module is instrumented independently, no link-time instrumentation is performed. For each module the following steps are done:
  * external declarations are inserted for the functions and global variables provided by the RTL
  * trace (superblock) instrumentation is done
  * each function call/exit is instrumented
  * debug info is written into the `tsan_rtl_debug_info` section

At the moment there are three external functions used by the client code. Those are: `bb_flush()` (used for flushing the thread-local event buffers, see below), `rtl_memcpy()` and `rtl_memmove()` (used to replace the [http://llvm.org/docs/LangRef.html#int_memcpy `llvm.memcpy.*`] and [http://llvm.org/docs/LangRef.html#int_memmove `llvm.memmove.*`] intrinsics.

During the instrumentation each function is divided into traces (also known as superblocks), which are pieces of the call graph with a single entry and (possibly) multiple exits containing no cycles. For each trace the maximum possible number of memory operations is known at compile time, so it is possible to create a static record containing the following information about the trace:
{{{
struct TraceInfoPOD {
  enum { kLiteRaceNumTids = 8 };  // takes zero bytes
  size_t n_mops_;
  size_t pc_;
  size_t counter_;
  uint32_t literace_counters[kLiteRaceNumTids];
  int32_t literace_num_to_skip[kLiteRaceNumTids];
  MopInfo mops_[1];
};
}}}
, where `MopInfo` is defined as follows:
{{{
struct MopInfo {
  uintptr_t pc;
  uint32_t  size;
  bool      is_write;
};
}}}

Each trace entry is instrumented with the call to `bb_flush(&current_trace_info)`, which flushes the events collected executing the previous trace and tells ThreadSanitizer where to get the information about the current trace. Each memory operation ([http://llvm.org/docs/LangRef.html#i_load load] or [http://llvm.org/docs/LangRef.html#i_store store]) is instrumented 

= Useful ThreadSanitizer flags =
  * `--suppressions=<filename>`
  * `--ignore=<filename>`
  * `--literace_sampling`
  * `--v`

= Future development =
  * document the items marked as done
  * make racecheck_unittest pass (see http://code.google.com/p/data-race-test/issues/detail?id=52 for the status)
  * support [ LiteRaceSampling literace sampling ] *DONE*
  * try this on something big (Chromium?)
  * compare the performance with Valgrind- or PIN-based ThreadSanitizer
  * use escape analysis to reduce the number of instrumented operations
  * implement *fast* event logging in the RTL for offline mode
  * use PIN or other lightweight instrumentation framework to handle uninstrumented libraries
  * write a gcc plugin for program instrumentation
  * make it possible to switch between instrumented and uninstrumented versions at runtime
  * use ignore files during compilation